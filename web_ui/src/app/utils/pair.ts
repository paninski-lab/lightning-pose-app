/**
 * A convenience class to represent a pair of generically typed values.
 * It provides methods to easily convert the pair to a string key for Maps
 * and reconstruct it from such a key.
 */
export class Pair<T1, T2> {
  public readonly first: T1;
  public readonly second: T2;

  /**
   * Creates a new Pair instance.
   * @param first The first value of the pair.
   * @param second The second value of the pair.
   */
  constructor(first: T1, second: T2) {
    this.first = first;
    this.second = second;
  }

  /**
   * Converts this Pair instance into a unique string key suitable for use in a Map.
   * It uses `JSON.stringify` to safely serialize the pair's contents,
   * ensuring consistent and reliable key generation even with complex values (if JSON-serializable).
   *
   * @returns A string representation of the pair that can serve as a Map key.
   */
  public toMapKey(): string {
    // We wrap the values in an array before stringifying to ensure a consistent, ordered structure.
    return JSON.stringify([this.first, this.second]);
  }

  /**
   * Reconstructs a Pair instance from a string key previously generated by `toMapKey()`.
   * This is a static method as it does not operate on an existing Pair instance.
   *
   * @param key The string key to parse, expected to be in the format generated by `toMapKey()`.
   * @returns A new Pair instance containing the parsed values.
   * @throws {Error} If the key is not a valid JSON string representing a two-element array.
   */
  public static fromMapKey<U1, U2>(key: string): Pair<U1, U2> {
    try {
      const parsed = JSON.parse(key);
      // Ensure the parsed result is an array with exactly two elements.
      if (Array.isArray(parsed) && parsed.length === 2) {
        // We use type assertions here because JSON.parse returns `any`.
        return new Pair<U1, U2>(parsed[0] as U1, parsed[1] as U2);
      } else {
        throw new Error(
          'Invalid key format: Expected a JSON array with two elements.',
        );
      }
    } catch (e) {
      // Provide a more informative error message if parsing fails.
      throw new Error(
        `Failed to parse Map key "${key}": ${e instanceof Error ? e.message : String(e)}`,
      );
    }
  }

  /**
   * Provides a human-readable string representation of the Pair for debugging or logging.
   * @returns A string like "Pair(value1, value2)".
   */
  public toString(): string {
    return `Pair(${String(this.first)}, ${String(this.second)})`;
  }

  /**
   * Performs a value-based comparison with another Pair instance.
   * This method is for direct Pair-to-Pair comparison, not for Map key comparison.
   * Note: This uses strict equality (===) for its members. For deep comparison of nested objects,
   * you'd need a more complex equality check.
   *
   * @param other The other Pair instance to compare against.
   * @returns True if both pairs have identical first and second values, false otherwise.
   */
  public equals(other: Pair<T1, T2>): boolean {
    return this.first === other.first && this.second === other.second;
  }
}
